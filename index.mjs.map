{"version":3,"file":"index.mjs","sources":["../lib/main.js","../lib/index.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar isPositiveInteger = require( '@stdlib/assert-is-positive-integer' ).isPrimitive;\nvar isNumber = require( '@stdlib/assert-is-number' ).isPrimitive;\nvar isnan = require( '@stdlib/math-base-assert-is-nan' );\nvar Float64Array = require( '@stdlib/array-float64' );\nvar format = require( '@stdlib/error-tools-fmtprodmsg' );\n\n\n// MAIN //\n\n/**\n* Returns an accumulator function which incrementally computes a moving unbiased sample covariance.\n*\n* ## Method\n*\n* -   Let \\\\(W\\\\) be a window of \\\\(N\\\\) elements over which we want to compute an unbiased sample covariance.\n*\n* -   We begin by defining the covariance \\\\( \\operatorname{cov}_n(x,y) \\\\) for a window \\\\(n\\\\) as follows\n*\n*     ```tex\n*     \\operatorname{cov}_n(x,y) &= \\frac{C_n}{n}\n*     ```\n*\n*     where \\\\(C_n\\\\) is the co-moment, which is defined as\n*\n*     ```tex\n*     C_n = \\sum_{i=1}^{N} ( x_i - \\bar{x}_n ) ( y_i - \\bar{y}_n )\n*     ```\n*\n*     and where \\\\(\\bar{x}_n\\\\) and \\\\(\\bar{y}_n\\\\) are the sample means for \\\\(x\\\\) and \\\\(y\\\\), respectively, and \\\\(i=1\\\\) specifies the first element in a window.\n*\n* -   The sample mean is computed using the canonical formula\n*\n*     ```tex\n*     \\bar{x}_n = \\frac{1}{N} \\sum_{i=1}^{N} x_i\n*     ```\n*\n*     which, taking into account a previous window, can be expressed\n*\n*     ```tex\n*     \\begin{align*}\n*     \\bar{x}_n &= \\frac{1}{N} \\biggl( \\sum_{i=0}^{N-1} x_i - x_0 + x_N \\biggr) \\\\\n*               &= \\bar{x}_{n-1} + \\frac{x_N - x_0}{N}\n*     \\end{align*}\n*     ```\n*\n*     where \\\\(x_0\\\\) is the first value in the previous window.\n*\n* -   We can substitute into the co-moment equation\n*\n*     ```tex\n*     \\begin{align*}\n*     C_n &= \\sum_{i=1}^{N} ( x_i - \\bar{x}_n ) ( y_i - \\bar{y}_n ) \\\\\n*         &= \\sum_{i=1}^{N} \\biggl( x_i - \\bar{x}_{n-1} - \\frac{x_N - x_0}{N} \\biggr) \\biggl( y_i - \\bar{y}_{n-1} - \\frac{y_N - y_0}{N} \\biggr) \\\\\n*         &= \\sum_{i=1}^{N} \\biggl( \\Delta x_{i,n-1} - \\frac{x_N - x_0}{N} \\biggr) \\biggl( \\Delta y_{i,n-1} - \\frac{y_N - y_0}{N} \\biggr)\n*     \\end{align*}\n*     ```\n*\n*     where\n*\n*     ```tex\n*     \\Delta x_{i,k} = x_i - \\bar{x}_{k}\n*     ```\n*\n* -   We can subsequently expand terms and apply a summation identity\n*\n*     ```tex\n*     \\begin{align*}\n*     C_n &= \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\Delta y_{i,n-1} - \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\biggl( \\frac{y_N - y_0}{N} \\biggr) - \\sum_{i=1}^{N} \\Delta y_{i,n-1} \\biggl( \\frac{x_N - x_0}{N} \\biggr) + \\sum_{i=1}^{N} \\biggl( \\frac{x_N - x_0}{N} \\biggr) \\biggl( \\frac{y_N - y_0}{N} \\biggr) \\\\\n*         &= \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\Delta y_{i,n-1} - \\biggl( \\frac{y_N - y_0}{N} \\biggr) \\sum_{i=1}^{N} \\Delta x_{i,n-1} - \\biggl( \\frac{x_N - x_0}{N} \\biggr) \\sum_{i=1}^{N} \\Delta y_{i,n-1} + \\frac{(x_N - x_0)(y_N - y_0)}{N}\n*     \\end{align*}\n*     ```\n*\n* -   Let us first consider the second term which we can reorganize as follows\n*\n*     ```tex\n*     \\begin{align*}\n*     \\biggl( \\frac{y_N - y_0}{N} \\biggr) \\sum_{i=1}^{N} \\Delta x_{i,n-1} &= \\biggl( \\frac{y_N - y_0}{N} \\biggr) \\sum_{i=1}{N} ( x_i - \\bar{x}_{n-1}) \\\\\n*         &= \\biggl( \\frac{y_N - y_0}{N} \\biggr) \\sum_{i=1}^{N} x_i - \\biggl( \\frac{y_N - y_0}{N} \\biggr) \\sum_{i=1}^{N} \\bar{x}_{n-1} \\\\\n*         &= (y_N - y_0) \\bar{x}_{n} - (y_N - y_0)\\bar{x}_{n-1} \\\\\n*         &= (y_N - y_0) (\\bar{x}_{n} - \\bar{x}_{n-1}) \\\\\n*         &= \\frac{(x_N - x_0)(y_N - y_0)}{N}\n*     \\end{align*}\n*     ```\n*\n* -   The third term can be reorganized in a manner similar to the second term such that\n*\n*     ```tex\n*     \\biggl( \\frac{x_N - x_0}{N} \\biggr) \\sum_{i=1}^{N} \\Delta y_{i,n-1} = \\frac{(x_N - x_0)(y_N - y_0)}{N}\n*     ```\n*\n* -   Substituting back into the equation for the co-moment\n*\n*     ```tex\n*     \\begin{align*}\n*     C_n &= \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\Delta y_{i,n-1} - \\frac{(x_N - x_0)(y_N - y_0)}{N} - \\frac{(x_N - x_0)(y_N - y_0)}{N} + \\frac{(x_N - x_0)(y_N - y_0)}{N} \\\\\n*         &= \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\Delta y_{i,n-1} - \\frac{(x_N - x_0)(y_N - y_0)}{N}\n*     \\end{align*}\n*     ```\n*\n* -   Let us now consider the first term which we can modify as follows\n*\n*     ```tex\n*     \\begin{align*}\n*     \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\Delta y_{i,n-1} &= \\sum_{i=1}^{N} (x_i - \\bar{x}_{n-1})(y_i - \\bar{y}_{n-1}) \\\\\n*         &= \\sum_{i=1}^{N-1} (x_i - \\bar{x}_{n-1})(y_i - \\bar{y}_{n-1}) + (x_N - \\bar{x}_{n-1})(y_N - \\bar{y}_{n-1}) \\\\\n*         &= \\sum_{i=1}^{N-1} (x_i - \\bar{x}_{n-1})(y_i - \\bar{y}_{n-1}) + (x_N - \\bar{x}_{n-1})(y_N - \\bar{y}_{n-1}) + (x_0 - \\bar{x}_{n-1})(y_0 - \\bar{y}_{n-1}) - (x_0 - \\bar{x}_{n-1})(y_0 - \\bar{y}_{n-1}) \\\\\n*         &= \\sum_{i=0}^{N-1} (x_i - \\bar{x}_{n-1})(y_i - \\bar{y}_{n-1}) + (x_N - \\bar{x}_{n-1})(y_N - \\bar{y}_{n-1}) - (x_0 - \\bar{x}_{n-1})(y_0 - \\bar{y}_{n-1})\n*     \\end{align*}\n*     ```\n*\n*     where we recognize that the first term equals the co-moment for the previous window\n*\n*     ```tex\n*     C_{n-1} = \\sum_{i=0}^{N-1} (x_i - \\bar{x}_{n-1})(y_i - \\bar{y}_{n-1})\n*     ```\n*\n*     In which case,\n*\n*     ```tex\n*     \\begin{align*}\n*     \\sum_{i=1}^{N} \\Delta x_{i,n-1} \\Delta y_{i,n-1} &= C_{n-1} + (x_N - \\bar{x}_{n-1})(y_N - \\bar{y}_{n-1}) - (x_0 - \\bar{x}_{n-1})(y_0 - \\bar{y}_{n-1}) \\\\\n*         &= C_{n-1} + \\Delta x_{N,n-1} \\Delta y_{N,n-1} - \\Delta x_{0,n-1} \\Delta y_{0,n-1}\n*     \\end{align*}\n*     ```\n*\n* -   Substituting into the equation for the co-moment\n*\n*     ```tex\n*     C_n = C_{n-1} + \\Delta x_{N,n-1} \\Delta y_{N,n-1} - \\Delta x_{0,n-1} \\Delta y_{0,n-1} - \\frac{(x_N - x_0)(y_N - y_0)}{N}\n*     ```\n*\n* -   We can make one further modification to the last term\n*\n*     ```tex\n*     \\begin{align*}\n*     \\frac{(x_N - x_0)(y_N - y_0)}{N} &= \\frac{(x_N - \\bar{x}_{n-1} - x_0 + \\bar{x}_{n-1})(y_N - \\bar{y}_{n-1} - y_0 + \\bar{y}_{n-1})}{N} \\\\\n*         &= \\frac{(\\Delta x_{N,n-1} - \\Delta x_{0,n-1})(\\Delta y_{N,n-1} - \\Delta y_{0,n-1})}{N}\n*     \\end{align*}\n*     ```\n*\n*     which, upon substitution into the equation for the co-moment, yields\n*\n*     ```tex\n*     C_n = C_{n-1} + \\Delta x_{N,n-1} \\Delta y_{N,n-1} - \\Delta x_{0,n-1} \\Delta y_{0,n-1} - \\frac{(\\Delta x_{N,n-1} - \\Delta x_{0,n-1})(\\Delta y_{N,n-1} - \\Delta y_{0,n-1})}{N}\n*     ```\n*\n*\n* @param {PositiveInteger} W - window size\n* @param {number} [meanx] - mean value\n* @param {number} [meany] - mean value\n* @throws {TypeError} first argument must be a positive integer\n* @throws {TypeError} second argument must be a number\n* @throws {TypeError} third argument must be a number\n* @returns {Function} accumulator function\n*\n* @example\n* var accumulator = incrmcovariance( 3 );\n*\n* var v = accumulator();\n* // returns null\n*\n* v = accumulator( 2.0, 1.0 );\n* // returns 0.0\n*\n* v = accumulator( -5.0, 3.14 );\n* // returns ~-7.49\n*\n* v = accumulator( 3.0, -1.0 );\n* // returns -8.35\n*\n* v = accumulator( 5.0, -9.5 );\n* // returns -29.42\n*\n* v = accumulator();\n* // returns -29.42\n*\n* @example\n* var accumulator = incrmcovariance( 3, -2.0, 10.0 );\n*/\nfunction incrmcovariance( W, meanx, meany ) {\n\tvar buf;\n\tvar dx0;\n\tvar dxN;\n\tvar dy0;\n\tvar dyN;\n\tvar mx;\n\tvar my;\n\tvar wi;\n\tvar C;\n\tvar N;\n\tvar n;\n\tvar i;\n\tif ( !isPositiveInteger( W ) ) {\n\t\tthrow new TypeError( format( '0dj4o', W ) );\n\t}\n\tbuf = new Float64Array( 2*W ); // strided array\n\tn = W - 1;\n\tC = 0.0;\n\twi = -1;\n\tN = 0;\n\tif ( arguments.length > 1 ) {\n\t\tif ( !isNumber( meanx ) ) {\n\t\t\tthrow new TypeError( format( '0dj4N', meanx ) );\n\t\t}\n\t\tif ( !isNumber( meany ) ) {\n\t\t\tthrow new TypeError( format( '0dj4O', meany ) );\n\t\t}\n\t\tmx = meanx;\n\t\tmy = meany;\n\t\treturn accumulator2;\n\t}\n\tmx = 0.0;\n\tmy = 0.0;\n\treturn accumulator1;\n\n\t/**\n\t* If provided a value, the accumulator function returns an updated unbiased sample covariance. If not provided a value, the accumulator function returns the current unbiased sample covariance.\n\t*\n\t* @private\n\t* @param {number} [x] - input value\n\t* @param {number} [y] - input value\n\t* @returns {(number|null)} unbiased sample covariance or null\n\t*/\n\tfunction accumulator1( x, y ) {\n\t\tvar v1;\n\t\tvar v2;\n\t\tvar k;\n\t\tvar j;\n\t\tif ( arguments.length === 0 ) {\n\t\t\tif ( N === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( N === 1 ) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\tif ( N < W ) {\n\t\t\t\treturn C / (N-1);\n\t\t\t}\n\t\t\treturn C / n;\n\t\t}\n\t\t// Update the window and strided array indices for managing the circular buffer:\n\t\twi = (wi+1) % W;\n\t\ti = 2 * wi;\n\n\t\t// Case: an incoming value is NaN, the sliding co-moment is automatically NaN...\n\t\tif ( isnan( x ) || isnan( y ) ) {\n\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\tC = NaN;\n\t\t}\n\t\t// Case: initial window...\n\t\telse if ( N < W ) {\n\t\t\tbuf[ i ] = x; // update buffer\n\t\t\tbuf[ i+1 ] = y;\n\n\t\t\tN += 1;\n\t\t\tdxN = x - mx;\n\t\t\tmx += dxN / N;\n\t\t\tmy += ( y-my ) / N;\n\t\t\tC += dxN * ( y-my ); // Note: repeated `y-my` is intentional, as `my` is updated when used here\n\t\t\tif ( N === 1 ) {\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t\treturn C / (N-1);\n\t\t}\n\t\t// Case: N = W = 1\n\t\telse if ( N === 1 ) {\n\t\t\treturn 0.0;\n\t\t}\n\t\t// Case: an outgoing value is NaN, and, thus, we need to compute the accumulated values...\n\t\telse if ( isnan( buf[ i ] ) || isnan( buf[ i+1 ] ) ) {\n\t\t\tN = 1;\n\t\t\tmx = x;\n\t\t\tmy = y;\n\t\t\tC = 0.0;\n\t\t\tfor ( k = 0; k < W; k++ ) {\n\t\t\t\tj = 2 * k; // convert to a strided array index\n\t\t\t\tif ( j !== i ) {\n\t\t\t\t\tv1 = buf[ j ];\n\t\t\t\t\tv2 = buf[ j+1 ];\n\t\t\t\t\tif ( isnan( v1 ) || isnan( v2 ) ) {\n\t\t\t\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\t\t\t\tC = NaN;\n\t\t\t\t\t\tbreak; // co-moment is automatically NaN, so no need to continue\n\t\t\t\t\t}\n\t\t\t\t\tN += 1;\n\t\t\t\t\tdxN = v1 - mx;\n\t\t\t\t\tmx += dxN / N;\n\t\t\t\t\tmy += ( v2-my ) / N;\n\t\t\t\t\tC += dxN * ( v2-my ); // Note: repeated `y-my` is intentional, as `my` is updated when used here\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Case: neither the current co-moment nor the incoming values are NaN, so we need to update the accumulated values...\n\t\telse if ( isnan( C ) === false ) {\n\t\t\tdx0 = buf[ i ] - mx;\n\t\t\tdy0 = buf[ i+1 ] - my;\n\t\t\tdxN = x - mx;\n\t\t\tdyN = y - my;\n\t\t\tC += (dxN*dyN) - (dx0*dy0) - ( (dxN-dx0)*(dyN-dy0)/W );\n\t\t\tmx += ( dxN-dx0 ) / W;\n\t\t\tmy += ( dyN-dy0 ) / W;\n\t\t}\n\t\t// Case: the current co-moment is NaN, so nothing to do until the buffer no longer contains NaN values...\n\t\tbuf[ i ] = x;\n\t\tbuf[ i+1 ] = y;\n\n\t\treturn C / n;\n\t}\n\n\t/**\n\t* If provided a value, the accumulator function returns an updated unbiased sample covariance. If not provided a value, the accumulator function returns the current unbiased sample covariance.\n\t*\n\t* @private\n\t* @param {number} [x] - input value\n\t* @param {number} [y] - input value\n\t* @returns {(number|null)} unbiased sample covariance or null\n\t*/\n\tfunction accumulator2( x, y ) {\n\t\tvar k;\n\t\tvar j;\n\t\tif ( arguments.length === 0 ) {\n\t\t\tif ( N === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif ( N < W ) {\n\t\t\t\treturn C / N;\n\t\t\t}\n\t\t\treturn C / W;\n\t\t}\n\t\t// Update the window and strided array indices for managing the circular buffer:\n\t\twi = (wi+1) % W;\n\t\ti = 2 * wi;\n\n\t\t// Case: an incoming value is NaN, the sliding co-moment is automatically NaN...\n\t\tif ( isnan( x ) || isnan( y ) ) {\n\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\tC = NaN;\n\t\t}\n\t\t// Case: initial window...\n\t\telse if ( N < W ) {\n\t\t\tbuf[ i ] = x; // update buffer\n\t\t\tbuf[ i+1 ] = y;\n\n\t\t\tN += 1;\n\t\t\tC += ( x-mx ) * ( y-my );\n\t\t\treturn C / N;\n\t\t}\n\t\t// Case: an outgoing value is NaN, and, thus, we need to compute the accumulated values...\n\t\telse if ( isnan( buf[ i ] ) || isnan( buf[ i+1 ] ) ) {\n\t\t\tC = 0.0;\n\t\t\tfor ( k = 0; k < W; k++ ) {\n\t\t\t\tj = 2 * k; // convert to a strided array index\n\t\t\t\tif ( j !== i ) {\n\t\t\t\t\tif ( isnan( buf[ j ] ) || isnan( buf[ j+1 ] ) ) {\n\t\t\t\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\t\t\t\tC = NaN;\n\t\t\t\t\t\tbreak; // co-moment is automatically NaN, so no need to continue\n\t\t\t\t\t}\n\t\t\t\t\tC += ( buf[j]-mx ) * ( buf[j+1]-my );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Case: neither the current co-moment nor the incoming values are NaN, so we need to update the accumulated values...\n\t\telse if ( isnan( C ) === false ) {\n\t\t\t// Use textbook formula along with simplification arising from difference of sums:\n\t\t\tC += ( (x-mx)*(y-my) ) - ( (buf[i]-mx)*(buf[i+1]-my) );\n\t\t}\n\t\t// Case: the current co-moment is NaN, so nothing to do until the buffer no longer contains NaN values...\n\t\tbuf[ i ] = x;\n\t\tbuf[ i+1 ] = y;\n\n\t\treturn C / W;\n\t}\n}\n\n\n// EXPORTS //\n\nmodule.exports = incrmcovariance;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Compute a moving unbiased sample covariance incrementally.\n*\n* @module @stdlib/stats-incr-mcovariance\n*\n* @example\n* var incrmcovariance = require( '@stdlib/stats-incr-mcovariance' );\n*\n* var accumulator = incrmcovariance( 3 );\n*\n* var v = accumulator();\n* // returns null\n*\n* v = accumulator( 2.0, 1.0 );\n* // returns 0.0\n*\n* v = accumulator( -5.0, 3.14 );\n* // returns ~-7.49\n*\n* v = accumulator( 3.0, -1.0 );\n* // returns -8.35\n*\n* v = accumulator( 5.0, -9.5 );\n* // returns -29.42\n*\n* v = accumulator();\n* // returns -29.42\n*/\n\n// MODULES //\n\nvar incrmcovariance = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = incrmcovariance;\n"],"names":["isPositiveInteger","require$$0","isPrimitive","isNumber","require$$1","isnan","require$$2","Float64Array","require$$3","format","require$$4","lib","W","meanx","meany","buf","dx0","dxN","dy0","dyN","mx","my","wi","C","N","n","i","TypeError","arguments","length","accumulator2","accumulator1","x","y","v1","v2","k","j","NaN"],"mappings":"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"}